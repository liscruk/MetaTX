#!/usr/bin/env python

import os
import sys
import re

RESULTS = config["results"]
SAMPLES = config["samples"]
SPECIES = config["species"]
REFNAME = SPECIES[0]+"."+SPECIES[1]

# Get reference of human (if human is involved)
refHuman = config["hg38Seq"]
anHuman = config["hg38Gtf"]
txHuman = config["hg38Tx"]

# Get reference of Xeno or Meta organism
refXeno = config["XenoSeq"]
anXeno = config["XenoGtf"]
txXeno = config["XenoTx"] 


# Define output list to which results will be appended
output = list()

if config["mode"].lower() == "canonical":
	output.append(RESULTS+"counts/tx/quant.tsv")
	output.append(
		collect(RESULTS+"bam/tx/{sample}.txt",sample = SAMPLES))

if config["mode"].lower() == "novel":
	output.append(RESULTS + "refs/Hybrid_genome." + REFNAME + ".fa")
	include:"../resources/novelTranscripts.smk"

if config["mode"].lower() == "both":
	output.append(RESULTS+"counts/tx/quant.tsv")
	output.append(RESULTS + "refs/Hybrid_genome." + REFNAME + ".fa")
	include:"../resources/novelTranscripts.smk"


# Prep output with rule all
rule all:
	input:
		output

### Rule will be called no matter since it is required by all options.
### The ressources required are minor since it is basically just concatenation.
rule makeRef:
	input:
		# Host reference fasta
		hr = refHuman,

		# Host reference annotation gtf
		ha = anHuman,

		# Host reference transcriptome fasta
		hx = txHuman,

		# Xeno or pathogen model fasta
		xr = refXeno,

		# Xeno or pathogen gtf NOT gff3
		xa = anXeno,

		# Xeno or pathogen transcripts fasta
		xx = txXeno

	output:
		rHyb = RESULTS + "refs/Hybrid_genome." + REFNAME + ".fa",
		anHyb = RESULTS + "refs/Hybrid_annotation." + REFNAME + ".gtf",
		txHyb = RESULTS + "refs/Hybrd_transcriptome." + REFNAME + ".fa"
	conda:
		"MetaTx"

	shell:"""
		cat {input.hr} {input.xr} > {output.rHyb};
		cat {input.hx} {input.xx} > {output.txHyb}
		grep -v '^#' {input.hx} > {output.anHyb};
		grep -v '^#' {input.xa} >> {output.anHyb}

	"""
### Canonical workflow perform competetive hybrid mapping on a hybrid reference generated per run.
### If you stick to the model it might make sense to keep the reference stable. 
rule Map:
	input:
		reads = lambda wildcards: config["samples"][wildcards.sample],
		ref = RESULTS + "refs/Hybrd_transcriptome." + REFNAME + ".fa"
	output:
		bam = RESULTS+"bam/tx/{sample}.bam"
	threads:
		config["threads"]
	params:
		ref = RESULTS + "refs/Hybrd_transcriptome." + REFNAME + ".fa"
	conda:
		"MetaTx"

	shell:"""
		minimap2 -t {threads} -ax map-ont -uf -Y {params.ref} {input.reads} | \
		samtools view -bS - | \
		samtools sort -@ {threads} -o {output.bam};
	"""
### Simple mapping statistics gathering. We'd like to have good map rates.
rule flagstat:
	input:
		bam = RESULTS+"bam/tx/{sample}.bam"
	output:
		stat = RESULTS+"bam/tx/{sample}.txt"
	conda:
		"MetaTx"
	
	shell:"""
		samtools flagstat {input.bam} -@ {threads} > {output.stat};
	"""
### Generation quantifcation by salmon for seperate mapping
rule salmonQuant:
	input:
		bam = RESULTS+"bam/tx/{sample}.bam",
		trp = RESULTS + "refs/Hybrd_transcriptome." + REFNAME + ".fa"
	output:
		trp_quant = RESULTS+"counts/{sample}/quant.sf",
		trp_dir = directory(RESULTS+"counts/{sample}/")
	threads:
		config["threads"]
	conda:
		"salmon"
	shell:
		"salmon quant --noErrorModel -p {threads} -l U -t {input.trp} -a {input.bam} -o {output.trp_dir}"
### Merge tpms
rule salmonMerge:
	input:
		dirs = expand(RESULTS+"counts/{sample}/", sample=SAMPLES, species = SPECIES)
	output:
		tx = RESULTS+"counts/tx/quant.tsv",
	conda:
		"salmon"
	shell:"""
		salmon quantmerge --quants {input.dirs} --output {output.tx};
	"""

# rule salmonMergeGene:
# 	input:
# 		dirs = expand(RESULTS+"counts/{sample}_{species}/", sample=SAMPLES, species = SPECIES)
# 	output:
# 		mFs = RESULTS+"counts/gene/quant.tsv"
# 	conda:
# 		"salmon"
# 	shell:"""
# 		salmon quantmerge --genes --quants {input.dirs} --output {output}
# 	"""
